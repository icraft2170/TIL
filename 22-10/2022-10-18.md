## Item. 1
### 생성자 대신 정적 팩터리 메서드를 고려하라
> 💡 자바의 클래스는 `public constructor` 대신 `static factory method`를 제공할 수 있다.

##### 👍 장점
- 이름을 가질 수 있다.
	- <u>기본적으로 생성자에는 이름이 없지만 정적 팩터리 메서드를 사용하면 이름을 가질 수 있다.</u>  이름을 가질 수 있다는 것은 해당 정적 팩터리 메서드가 만드는 인스턴스에 대해 명확히 설명할 수 있다는 것을 의미한다. 코틀린에서는 정적 팩터리 메서드 대신 named argument로 그 의도 파악을 가능하도록 돕는다.
- 호출될 때 마다 인스턴스를 새로 생성할 필요가 없다.
	- 싱글턴 객체 혹은 `Boolean.valueOf(boolean)` 메서드가  대표적인 예시이다. 미리 생성해둔 혹은 새로 생성할 필요 없는(공유하는 상태가 존재하지 않는) 객체인 경우 불필요한 객체 생성을 막아 성능에 효능을 볼 수 있다.
- 반환 타입의 하위 객체를 반환할 수 있다.
	- `static factory method` 를 통해 하위 타입을 제공하게 되면 상위 타입이라는 하나의 인터페이스만 남겨두는 것이 된다. 개발자들은 여러 클래스를 기억할 필요 없이 가장 상위의 클래스로부터 정적 메서드를 찾아나서면 된다. 
	- 예시로는 `java.utli.Collections` 에 다양한 정적 팩터리 메서드를 통해 `ArrayList`, `Set` 등을 생성할 수 있다.
- 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
	- 다형성을 이용할 수 있는 객체라면 어떤 객체든 반환할 수 있다. 때문에 매개변수에 따라 다른 객체를 반환하게 하면 클라이언트 입장에서는 매개변수만 바꿔주더라도 다형성을 이용해 아에 다른 동작을 하게 할 수 있다. 
	- `java.util.EnumSet` 의 `EnumSet<E> noneOf(Class<E> elementType)`  가 예시이다.
- 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.
	- (추후 정리 필요)

##### 👎 단점
- 상속을 할 수 없다.
	- 생성자의 접근 제어자가 `private` 혹은 `protected` 로 하기 때문에 정적 팩토리 메서드만 제공해서는 상속이 불가능하다.
- Java Docs 로 만들어 주지 않는다.
	- Java Docs 는 리플렉션을 활용해 자동으로 API 문서를 만들어주는 도구이다. 이러한 자바 독스에서는 정적 팩터리 메서드를 인식하지 못하기 때문에 따로 구분해 만들어 주지 않아 문서에서 찾기 힘들다는 단점이 있다.

##### 네이밍 컨벤션
- `from` : 매개변수 하나를 받아서 해당 타입의 인스턴스를 반환하는 형변환 메서드
	- `Date.from()`
- `of` : 여러 매개변수를 받아서 적합한 타입의 인스턴스를 반환하는 집계 메서드 
	- `EnumSet.of(...)``
- `valueOf` : from 과 of 의 자세한 버전
	- `BigInteger.valueOf`
- `instance` , `getInstance` : 매개변수로 명시한 인스턴스를 반환. But, 싱글턴을 보장X
	- `StackWalker.getInstance()`
- `create`, `newInstance` : instance와 같지만 매번 프로토타입 패턴을 사용
	- `Array.newInstance`
- `getType` : 다른 클래스의 팩터리 메서드 정의할 때 사용 
	- `Files.getFileStore(path)`
- `newType` : newInstance와 같으나 다른 타입을 반환할 때 사용
	- `Files.newBufferedReader(path)`
- `type` : getType , newType의 간결한 버전
	- `Coleections.list()`



## Item. 2
### 생성자에게 매개변수가 많다면 빌더를 고려하라

##### 필요이유
필드가 많고 그 생성 패턴이 다양할 때, 점층적 생성자 패턴 많이 사용해 왔다. 하지만 생성자를 통해 의도를 파악하기 힘들고 코드가 복잡해지는 문제가 발생했다. 대안책으로 자바빈즈에 `setter` 메서드를 통해 추가하는 방법 역시 존재하지만 이 방법은 객체가 미완성인 구간이 너무 길어진다는 문제가 있다. 또한 자바빈즈 패턴의 경우 `setter`를 통해 객체 필드의 변경이 필요해 불변 객체를 만들 수 없다.

##### 빌더 패턴
위 문제들의 대안으로 빌더 패턴이 있다. 필더 패턴의경우 메서드 체이닝 방식으로 객체를 생성하는 방식을 말한다. 해당 방법은 명시적으로 필드를 채울 수 있다는 장점이 있다. (코틀린은 이 대안으로 명명된 매개변수(Named Argument)를 제공하지만 아직 자바에는 해당 기능을 제공하지 않는다.) 또한 객체 생성이 `build()` 메서드를 호출한 마지막 시점에 완료되기 때문에 일관성 문제역시 걱정 없다.

또한 빌더패턴의 경우 각 아규먼트를 받는 과정에서 해당 매개변수를 검증 할 수 있다.

##### 구현방법
[빌더패턴](https://internet-craft.tistory.com/69)

	핵심
	생성자나 정적 팩토리 메서드를 선택하기에는 매개변수가 너무 많다면 빌더 패턴도 나쁘지 않은 선택이 될 수 있다.


## Item. 3
### private 생성자나 열거 타입으로 싱글턴을 보증하라

##### 개요
상태가 없고, 시스템 전체에서 공유되도 상관 없는 객체의 경우 매번 새로 생성하는 것은 잦은 가비지 컬렉션과 메모리 할당등의 성능 문제를 유발할 수 있다. 때문에 오직 하나의 객체로 관리할 필요가 생기는 경우도 존재한다.

##### 싱글턴 패턴

싱글턴 패턴의 경우 생성자의 접근제어자를 `private`으로 하여 인스턴스화를 막고, 객체 내부에서 `static` Instance를 만들어 정적 팩터리 메서드를 통해 제공하는 디자인 패턴이다. 싱글턴 패턴은 다양한 구현 방법이 존재한다. 


## Item. 4
### 인스턴스화를 막기 위해 private 생성자를 사용하라

##### 개요
정적 메서드와 정적 필드만을 담은 클래스가 필요한 경우가 있다. 예로는 Util 메서드를 모아두거나, 상수의 모음이 있다. 코틀린의 경우 Top-Level 에도 함수를 작성할 수 있도록 제공하지만 기본적으로 Java의 경우 정적 메서드와 필드가 최선일 때가 있다. 자바는 인스턴스화가 가능하기 때문에 종종 이런 객체가 생성될 수 있다. 때문에 애초에 인스턴스화가 불가능하도록 막는 것이 중요할 수 있다.

##### 인스턴스화를 막는 방법
인스턴스화를 막기위해 종종 `abstract` 키워드를 사용해 추상 클래스로 만들어 준다. 하지만 추상 클래스는 하위 클래스를 만들어 인스턴스화가 가능하다.( 정말 이러는 사람이 있을지는 모르겠지만... ) 때문에 인스턴스화를 정말로 막고 싶다면 `private` 생성자를 추가해 기본 생성자가 필요 없게 하면서 인스턴스화를 막는 것이 가능하다.


## Item. 5
### 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라

##### 개요
클래스내에 다른 객체의 타입 이름이 존재하면 두 클래스 사이에는 결합도가 생긴다. 이러한 결합은 어떤 코드 변경에 있어 서로에게 영향을 주고 변경을 전파시킨다. 때문에 이름을 직접 등장 시키는 것은 좋지 않다. 하지만 객체를 사용하게 되면 `new` 키워드를 통해 인스턴스화가 필수적이다. 때문에 인스턴스화 과정마저 외부로 분리해낼 필요가 있다.

##### 의존성 주입 ( Dependency Injection )을 사용하라.
스프링 프레임워크에 주요 기능중 하나로 알려진 DI는 생성하는 인스턴스의 구체 타입을 숨겨 느슨한 결합을 만든다. 이러한 느슨한 결합은 변경의 전파를 최소화 해준다. DI는 프레임 워크가 없이도 `setter`, `constructor` 등을 통해 주입이 가능하지만, 코드 복잡도를 높일 수 있어 적절한 DI 프레임워크의 사용이 필요하다.


## Item. 6
### 불필요한 객체 생성을 피하라

똑같은 기능의 객체를 매번 생성하는 것보다 객체 하나를 재사용하는 것이 나을 때가 많다. 예를 들면 데이터 베이스 커넥션이나 서블릿 스레드가 예다. String의 경우도 상수 풀에 미리 생성해둔 String을 재활용하는 방법을 사용한다.

##### 관련 내용
- 플라이 웨이트 패턴
- 풀
	- 스레드 풀
	- 커넥션 풀
	- 상수 풀



## Item. 7
### 다 쓴 객체 참조를 해제하라 

자바는 기본적으로 직접 메모리관리를 하는 managed 언어가 아니고 unmanaged 언어이다 보니 메모리 관리에 신경을 쓰지 않아도 된다는 착각을 하는 경우가 많다. 하지만 자바 역시 메모리 누수로 OOM 혹은 디스크 페이징을 유발 할 수 있다.

##### 자바에서 생길 수 있는 메모리 누수
1. 자기 메모리를 직접 관리하는 클래스에 참조해제를 해주지 않은 경우
	- 특히 컬렉션 객체들이 해당 예시해 해당될 수 있다. 더 이상 사용하지 않은 요소를 배열에 가지고 있는 것은 메모리 누수에 영향을 줄 수 있다.
2. 메모리에 캐싱을 하는 것
	- 캐싱을 하고 캐시를 만료시켜주지 않으면 메모리 공간을 계속 차지하고 있어 메모리 누수가 생길 수 잇다.
3. 리스너(listener) 혹은 콜백
	- 클라이언트가 콜백을 등록만 하고 해제해주지 않으면 콜백이 계속 쌓여나갈 수 있음. 때문에 약함 참조로 저장할 필요가 있음.

## Item. 8
### finalizer 와 cleaner 사용을 피하라

자바는 두 가지 객체 소멸자를 제공한다. `finalizer` 와 `cleaner` 인데, `finalizer` 의 사용은 예측할 수 없어 사용이 불필요하고 Java 9에서는 Deprecated 되었다. `cleaner` 역시 `finalizer` 보다는 덜 하지만 역시 예측할 수 없고 위험하다. 때문에 사용을 자제해야 한다. 


	추가 내용
	- 두 메서드 모두 즉시 실행될 것이라는 보장을 해주지 않는다.


## Item. 9
### try-finally 보다는 try-with-resources를 사용하라

자바에는 `close` 메서드를 호출해 직접 닫아줘야하는 자원들이 있다. `JDBC` 를 사용하다 보면 `close` 메서드를 종족 보게된다. 과거에는 try-finally 구문의 finally에서 직접 `close` 메소드를 호출해 주었지만 해당 방식을 코드를 너무 더럽힌다는 문제가 있다.

이러한 문제 해결을 위하 자바 7에서 추가된 `try-with-resources` 가 있다. `AutoCloseable` 인터페이스를 구현한 객체를 자동으로 닫아주는 역할을 한다. 위 구문에 소괄호 내에서 생성된 인스턴스는 `AutoCloseable` 이 구현되어 있다면 해당 마커인터페이스를 확인하고 자동으로 삭제한다.

코틀린에서는 `try-with-resources` 구문이 존재하지 않는데, 이 때문에 `use` 메서드를 활용하여 인스턴스를 반환한다.
