# 스토리지 엔진 
> 스토리지 엔진은 DBMS에서 데이터를 메모리와 디스크에 저장하고 검색 및 관리하는 소프트웨어 컴포넌트로 각 노드에 데이터를 영구 저장한다. DBMS가 복잡한 쿼리 실행이 가능하도록 데이터 세밀 조작이 가능한 간단한 API를 제공하고 있다. 대표적으로 MySQL의 InnoDB와 MyISAM 이 있다.

	Tip
	DBMS에 대표적인 소프트웨어 컴포넌트로는 스토리지 엔진,실행 엔진,쿼리 프로세서,전송 계층이 있다.

### 장•단점 비교
스토리지 엔진의 설계 방법은 다양하게 제공된다. 그리고 이 방법들은 각각이 장•단점이 존재한다.

### DBMS의 구조

##### 트랜스포트
- 클라이언트 및 클러스터(복사된 시스템)와 통신 하는 작업을 담당한다.

##### 쿼리 프로세스
- 클라이언트에게 요청 받은 쿼리를 파싱(해석)하고 옵티마이징(최적화)해 실행엔진에게 전달하는 역할을 한다.
- 옵티마이징 작업으로는, 중복 제거, 통계및 데이터 위치에 따라 실행계획을 작성하고 가장 적합한 실행계획을 선택하도록 한다.


##### 실행 엔진
- 로컬 및 원격 실행의 결과를 결합하는 역할을 한다.

##### 스토리지 엔진
- 트랜잭션 매니징, 잠금 매니징, 액세스 메소드, 버퍼 매니징, 복구 매니징 역할을 한다. 
- 트랜잭션 매니져와 잠금 매니져는 논리적(트랜잭션)•물리적(잠금) 데이터 일관성 보장을한다.


### 인메모리 DBMS 와 디스크 기반 DBMS
DBMS는 데이터를 메모리 또는 디스크에 저장한다. 메모리에 저장하는 경우 인메모리 DBMS이고 디스크에 저장하는 경우 디스크 기반 DBMS라고 할 수 있다. 인메모리 DBMS의 경우 기본적으로 RAM에 저장하고 있기 때문에 훨씬 더 빠른 접근이 가능하다. 하지만 RAM의 경우 휘발성이며 SSD 나 HDD에 비해 가격이 비싸다는 단점이 있다.

비휘발성 램 (NVM) 이 대중화 되면 인 메모리 DBMS의 단점이 해소될 수도 있지만. 아직 충분한 Data 저장공간 확보가 불가하다.

	인메모리 데이터베이스의 지속성
	
	인메모리 DBMS는 데이터 지속성 확보를 위해 디스크에 데이터를 백업한다. 


### 칼럼형 DBMS와 로우형 DBMS

- 칼럼(Column)
	- 특정 Row의 특정 속성에 대한 값. 마치 User 테이블에 name.
- 로우(Row)
	- 논리적으로 같은 레코드에 속하는 값으 집합을 얘기한다.

칼럼 저장 방식의 경우 테이블을 수직 분할하고 로우 저장 방식은 수평 분할 한다. 전통적인 RDBMS는 대부분 로우형 DBMS이다. MonetDB, C-Store 등은 대표적인 칼럼형 오픈소스 데이터베이스이다.

##### 로우형 데이터베이스
데이터 레코드를 로우의 형태로 저장한다. 이 경우 한 개의 로우씩 접근하는 경우에 적합하다. 디스크에 반영구적으로 저장한 데이터의 경우 블록 단위로 접근하기 때문에 한 블록에 모든 칼럼이 들어가 칼럼단위로 정보를 읽기에 효율적이다. 다만 여러 로우의 특정 필드를 읽기에는 비효율적일 수 있다. 요청하지 않은 필드까지 같은 블록에 페이징하고 있기 때문이다.

##### 컬럼형 데이터베이스
데이터를 캍은 칼럼끼리 디스크에 연속해 저장하는 방식이다. 특정 칼럼은 읽어올 때 연속적으로 디스크에 저장되어있기 때문에 랜덤 I/O 가 아닌 연속 I/O가 가능해진다. 즉, 특정 칼럼을 읽는 것이 좀 더 효율적일 수 있다 때문에 집계및 분석 작업에 많이 사용된다.

- 같은 자료형 끼리 저장하여 압축률이 증가한다. 
- 벡터 연산이 가능해진다.
- 캐시 활용도와 처리 효율성이 높아진다.

##### 와이드 칼럼 스토어
Big Table 과 HBase와 같은 종류가 있는 와이드 칼럼 스토어는 일반적인 칼럼형 DBMS와 달리 데이터를 다차원의 맵으로 표현하고 여러 칼럼을 같은 자료형(칼럼 패밀리)로 저장한다. 키-밸류 형태의 스토리지에 적합하다.


### 데이터 파일과 인덱스 파일
DBMS는 데이터 파일과 인덱스 파일을 분리하여 저장한다. 데이터 파일에는 데이터 레코드를 저장하고 인덱스 파일에는 레코드에 대한 메타데이터를 저장하고 레코드 위치 찾기를 돕는다.

##### 데이터 파일
- 인덱스 구조형 테이블
	- 데이터를 순서대롤 정렬해 저장한다. 덕분에 삽입은 힘들지만 탐색은 빠르게 할 수 있다.
- 힙 구조형 테이블
	- 레코드를 정렬하지 않고 삽입 순서대로 저장한다. 때문에 삽입시에 파일 재구성이 필요 없지만 데이터의 실제 위치를 가리키는 인덱스가 필요하다.
- 해시 구조형 테이블
	- 해시 값에 해당하는 버킷에 분류해 저장한다. 

##### 인덱스 파일
- 저장된 데이터 레코드를 효율적으로 검색 가능하게 하는 자료구조다.
- **실제 데이터 레코드의 정렬 순서와 검색 키의 정렬 순서가 같은 인덱스를 클러스터형 인덱스라고 한다.**
- **인덱스 키를 기준으로 레코드가 정렬되지 않은 인덱스를 비클러스트형 인덱스라고 한다.**
- IOT(Index Organized Table)은 기본적으로 클러스터형 인덱스이며 MySQL은 기본 키(ID)를 통해 정렬하여 저장한다. 직접 생성하지 않아도 내부적으로 생성하기 때문에 기본 키 컬럼을 생성하지 않는 것은 손해이다.

##### 기본 인덱스를 통한 간접 참조
DBMS를 개발하는 과정에서 데이터 레코드를 직접 참조해야 하는지 기본 인덱스를 통해 접근해야 하는지 의견이 갈린다고 한다. 이유는 두 방식 모두 장단점이 있기 떄문인데 직접 참조를 하면 바로 읽어낼 수 있기 때문에 읽기에 대한 오버헤드가 준다. 하지만 데이터를 갱신할 일이 있으면 각 레코드의 포인터를 수정해야 하는 오버헤드가 생긴다. 즉, 기본 인덱스를 통해 간접 참조하는 경우 갱신 비용이 줄지만 탐색 비용이 더 들고 인덱스를 거치지 않고 직접 참조하는 경우 갱신 비용은 늘지만 탐색 비용은 감소한다. 갱신이 잦은 경우 인덱스가 많아지면 포인터 갱신이 문제가 생길 수 있다. 때문에 MySQL의 InnoDB의 경우 인덱스를 사용해 간접 참조하고 있다.

**보조 인덱스 -> 기본 인덱스를 참조 -> 데이터 파일 레코드**
- 데이터 갱신에 있어 기본 인덱스가 참조하는 데이터 파일의 위치만 변경해주면 된다.

**데이터파일 레코드** 
- 데이터파일을 갱신하고 해당 데이터파일을 참조하는 각 인덱스들의 참조내용을 변경해주어야 한다.


##### 버퍼링과 불변성, 순서화
데이터베이스 자료 구조에는 세 가지 분류 기준이 있다.
- 버퍼링을 사용하는지?
	- 디스크에 쓰기 전에 인메모리에 저장할지 여부
- 불변 파일을 사용하는지?
	- 한 번 쓴 파일을 갱신할지 아니면 이미 쓴 내용은 수정 불가하고 추가만 가능하게 할지
- 데이터 저장시 값의 순서를 유지하는지?
	- 데이터 레코드를 키 순서로 저장할지 여부





# 내 언어로 정리
스토리지 엔진은 DBMS의 컴포넌트 중 하나로 데이터를 저장, 검색, 관리하는 역할을 담당한다.

로우형 DBMS 즉, 대부분의 RDBMS는 하나의 로우가 디스크의 같은 블록내에 저장되기 때문에 특정 필드만 가져오는 것과 그 로우 전체를 가져오는 것이 성능적으로 큰 차이가 없을 수 있다.

칼럼형 DBMS는 하나의 칼럼을 같은 세그먼트 또는 파일에 연속적으로 저장하고 있고 각 칼럼의 연관성을 메타정보를 통해 연결하기 떄문에 한 칼럼이 아니라 로우단위로 가져오기에는 비효율적일 수 있으나 특정 칼럼만 가져와야 하는 경우라면 연속적인 데이터를 풀 스캔하기가 더 쉬워진다.

어떤 레코드를 기본 인덱스를 통해 간접 참조하는 경우 갱신 비용이 줄지만 탐색 비용이 더 들고 인덱스를 거치지 않고 직접 참조하는 경우 갱신 비용은 늘지만 탐색 비용은 감소한다. 예시로 MySQL은 기본 인덱스를 통해 레코드를 간접 참조하고 있다.
